/*
 * generated by Xtext 2.10.0
 */
package edelta.validation

import com.google.inject.Inject
import edelta.edelta.EdeltaModifyEcoreOperation
import edelta.edelta.EdeltaProgram
import edelta.edelta.EdeltaUseAs
import edelta.lib.AbstractEdelta
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.common.types.JvmGenericType
import org.eclipse.xtext.common.types.JvmTypeReference
import org.eclipse.xtext.validation.Check
import org.eclipse.xtext.xbase.jvmmodel.IJvmModelAssociations
import org.eclipse.xtext.xbase.typesystem.^override.OverrideHelper
import org.eclipse.xtext.xbase.typesystem.references.StandardTypeReferenceOwner
import org.eclipse.xtext.xbase.typesystem.util.CommonTypeComputationServices
import org.eclipse.xtext.xbase.typesystem.util.Multimaps2

import static edelta.edelta.EdeltaPackage.Literals.*
import static edelta.util.EdeltaModelUtil.*

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class EdeltaValidator extends AbstractEdeltaValidator {

	public static val PREFIX = "edelta.";
	public static val TYPE_MISMATCH = PREFIX + "TypeMismatch";
	public static val INTERPRETER_TIMEOUT = PREFIX + "InterpreterTimeout";
	public static val INTERPRETER_ACCESS_STALE_ELEMENT = PREFIX + "InterpreterAccessStaleElement";
	public static val DUPLICATE_DECLARATION = PREFIX + "DuplicateDeclaration";
	public static val INVALID_SUBPACKAGE_IMPORT = PREFIX + "InvalidSubPackageImport";
	public static val INVALID_SUBPACKAGE_MODIFICATION = PREFIX + "InvalidSubPackageModification";

	@Inject CommonTypeComputationServices services
	@Inject OverrideHelper overrideHelper
	@Inject extension IJvmModelAssociations

	@Check
	def void checkValidUseAs(EdeltaUseAs useAs) {
		if (!isConformant(useAs, AbstractEdelta, useAs.type)) {
			error(
				"Not a valid type: must be an " + AbstractEdelta.name,
				EDELTA_USE_AS__TYPE,
				TYPE_MISMATCH
			)
		} else {
			val type = useAs.type.type
			if (type instanceof JvmGenericType) {
				// otherwise it's a JvmVoid, which means, unresolved
				// and an error is issued by other validators
				if (type.isAbstract) {
					error(
						"Cannot be an abstract type",
						EDELTA_USE_AS__TYPE,
						TYPE_MISMATCH
					)
				}
			}
		}
	}

	@Check
	def void checkProgram(EdeltaProgram p) {
		var metamodelIndex = 0
		for (metamodel : p.metamodels) {
			val rootPackage = findRootSuperPackage(metamodel)
			if (rootPackage !== null) {
				error(
					"Invalid subpackage import '" + metamodel.name + "'",
					p,
					EDELTA_PROGRAM__METAMODELS,
					metamodelIndex,
					INVALID_SUBPACKAGE_IMPORT,
					rootPackage.name // the fix for the import
				)
			}
			metamodelIndex++
		}

		val javaClass = p.jvmElements.filter(JvmGenericType).head
		val methods = overrideHelper.getResolvedFeatures(javaClass).declaredOperations

		val map = Multimaps2.newLinkedHashListMultimap

		for (d : methods) {
			map.put(d.resolvedErasureSignature, d.getDeclaration)
		}

		for (entry : map.asMap.entrySet) {
			val duplicates = entry.value
			if (duplicates.size > 1) {
				for (d : duplicates) {
					val source = d.primarySourceElement
					error(
						"Duplicate definition '" + d.simpleName + "'",
						source,
						source.eClass.getEStructuralFeature("name"),
						DUPLICATE_DECLARATION
					)
				}
			}
		}
	}

	@Check
	def void checkModifyEcore(EdeltaModifyEcoreOperation op) {
		if (findRootSuperPackage(op.epackage) !== null) {
			error(
				"Invalid direct subpackage modification '" + op.epackage.name + "'",
				op,
				EDELTA_MODIFY_ECORE_OPERATION__EPACKAGE,
				INVALID_SUBPACKAGE_MODIFICATION
			)
		}
	}

	def isConformant(EObject context, Class<?> expected, JvmTypeReference actual) {
		val actualType = actual.toLightweightTypeReference(context)
		actualType.isSubtypeOf(expected)
	}

	def toLightweightTypeReference(JvmTypeReference typeRef, EObject context) {
		return newTypeReferenceOwner(context).toLightweightTypeReference(typeRef)
	}

	def protected newTypeReferenceOwner(EObject context) {
		return new StandardTypeReferenceOwner(services, context);
	}
}
