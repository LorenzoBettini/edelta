/*
 * generated by Xtext 2.10.0
 */
package edelta.validation

import com.google.inject.Inject
import edelta.edelta.EdeltaEcoreReferenceExpression
import edelta.edelta.EdeltaModifyEcoreOperation
import edelta.edelta.EdeltaProgram
import edelta.edelta.EdeltaUseAs
import edelta.lib.AbstractEdelta
import edelta.resource.derivedstate.EdeltaDerivedStateHelper
import edelta.util.EdeltaEcoreHelper
import edelta.util.EdeltaModelUtil
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.common.types.JvmGenericType
import org.eclipse.xtext.common.types.JvmTypeReference
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.xtext.util.IResourceScopeCache
import org.eclipse.xtext.validation.Check
import org.eclipse.xtext.xbase.jvmmodel.IJvmModelAssociations
import org.eclipse.xtext.xbase.typesystem.^override.OverrideHelper
import org.eclipse.xtext.xbase.typesystem.references.StandardTypeReferenceOwner
import org.eclipse.xtext.xbase.typesystem.util.CommonTypeComputationServices
import org.eclipse.xtext.xbase.typesystem.util.Multimaps2

import static edelta.edelta.EdeltaPackage.Literals.*
import static edelta.util.EdeltaModelUtil.*

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class EdeltaValidator extends AbstractEdeltaValidator {

	public static val PREFIX = "edelta.";
	public static val TYPE_MISMATCH = PREFIX + "TypeMismatch";
	public static val INTERPRETER_TIMEOUT = PREFIX + "InterpreterTimeout";
	public static val INTERPRETER_ACCESS_REMOVED_ELEMENT = PREFIX + "InterpreterAccessRemovedElement";
	public static val INTERPRETER_ACCESS_RENAMED_ELEMENT = PREFIX + "InterpreterAccessRenamedElement";
	public static val INTERPRETER_ACCESS_NOT_YET_EXISTING_ELEMENT = PREFIX + "InterpreterAccessNotYetExistingElement";
	public static val DUPLICATE_DECLARATION = PREFIX + "DuplicateDeclaration";
	public static val DUPLICATE_METAMODEL_IMPORT = PREFIX + "DuplicateMetamodelImport";
	public static val INVALID_SUBPACKAGE_IMPORT = PREFIX + "InvalidSubPackageImport";
	public static val INVALID_SUBPACKAGE_MODIFICATION = PREFIX + "InvalidSubPackageModification";
	public static val AMBIGUOUS_REFERENCE = PREFIX + "AmbiguousReference";
	public static val LIVE_VALIDATION_ERROR = PREFIX + "LiveValidationError";
	public static val LIVE_VALIDATION_WARNING = PREFIX + "LiveValidationWarning";
	public static val EPACKAGE_CYCLE = PREFIX + "EPackageCycle";
	public static val ECLASS_CYCLE = PREFIX + "EClassCycle";

	@Inject CommonTypeComputationServices services
	@Inject OverrideHelper overrideHelper
	@Inject extension IJvmModelAssociations
	@Inject extension EdeltaEcoreHelper
	@Inject extension IQualifiedNameProvider
	@Inject extension EdeltaDerivedStateHelper
	@Inject IResourceScopeCache cache

	@Check
	def void checkValidUseAs(EdeltaUseAs useAs) {
		if (!isConformant(useAs, AbstractEdelta, useAs.type)) {
			error(
				"Not a valid type: must be an " + AbstractEdelta.name,
				EDELTA_USE_AS__TYPE,
				TYPE_MISMATCH
			)
		} else {
			val type = useAs.type.type
			if (type instanceof JvmGenericType) {
				// otherwise it's a JvmVoid, which means, unresolved
				// and an error is issued by other validators
				if (type.isAbstract) {
					error(
						"Cannot be an abstract type",
						EDELTA_USE_AS__TYPE,
						TYPE_MISMATCH
					)
				}
			}
		}
	}

	@Check
	def void checkProgram(EdeltaProgram p) {
		var metamodelIndex = 0
		val metamodelImportSet = newHashSet
		for (metamodel : p.metamodels) {
			val rootPackage = findRootSuperPackage(metamodel)
			if (rootPackage !== null) {
				error(
					"Invalid subpackage import '" + metamodel.name + "'",
					p,
					EDELTA_PROGRAM__METAMODELS,
					metamodelIndex,
					INVALID_SUBPACKAGE_IMPORT,
					rootPackage.name // the fix for the import
				)
			}
			val metamodelImport = getMetamodelImportText(p, metamodelIndex)
			if (metamodelImportSet.contains(metamodelImport)) {
				error(
					"Duplicate metamodel import " + metamodelImport,
					p,
					EDELTA_PROGRAM__METAMODELS,
					metamodelIndex,
					DUPLICATE_METAMODEL_IMPORT,
					"" + metamodelIndex // the fix for the import
				)
			}
			metamodelImportSet.add(metamodelImport)
			metamodelIndex++
		}

		val javaClass = p.jvmElements.filter(JvmGenericType).head
		val methods = overrideHelper.getResolvedFeatures(javaClass).declaredOperations

		val map = Multimaps2.newLinkedHashListMultimap

		for (d : methods) {
			map.put(d.resolvedErasureSignature, d.getDeclaration)
		}

		for (entry : map.asMap.entrySet) {
			val duplicates = entry.value
			if (duplicates.size > 1) {
				for (d : duplicates) {
					val source = d.primarySourceElement
					error(
						"Duplicate definition '" + d.simpleName + "'",
						source,
						source.eClass.getEStructuralFeature("name"),
						DUPLICATE_DECLARATION
					)
				}
			}
		}

		val unresolvedEcoreReferences = p.eResource.unresolvedEcoreReferences
		for (ecoreRef : unresolvedEcoreReferences) {
			// it wasn't resolved during interpretation but it is
			// in the end
			if (!ecoreRef.enamedelement.eIsProxy) {
				error(
					"Element not yet available in this context: " +
						ecoreRef.enamedelement.fullyQualifiedName,
					ecoreRef,
					EDELTA_ECORE_REFERENCE__ENAMEDELEMENT,
					INTERPRETER_ACCESS_NOT_YET_EXISTING_ELEMENT
				)
			}
		}
	}

	@Check
	def void checkModifyEcore(EdeltaModifyEcoreOperation op) {
		if (findRootSuperPackage(op.epackage) !== null) {
			error(
				"Invalid direct subpackage modification '" + op.epackage.name + "'",
				op,
				EDELTA_MODIFY_ECORE_OPERATION__EPACKAGE,
				INVALID_SUBPACKAGE_MODIFICATION
			)
		}
	}

	@Check
	def void checkEcoreReferenceExpression(EdeltaEcoreReferenceExpression e) {
		val fqnames = cache.get("fqnamesOfEnamedElements", e.eResource) [
			getProgramENamedElements(e)
				.map[fullyQualifiedName]
				.filterNull
				.map[toString]
				.toSet
		]
		val refText = EdeltaModelUtil.getEcoreReferenceText(e.reference)
		// qualification '.' is the boundary for searching for matches
		val toSearch = "." + refText
		val matches = fqnames.filter[endsWith(toSearch)]
		if (matches.size > 1) {
			error(
				"Ambiguous reference '" + refText + "':\n" +
					matches.map["  " + it].join("\n"),
				e,
				EDELTA_ECORE_REFERENCE_EXPRESSION__REFERENCE,
				AMBIGUOUS_REFERENCE,
				matches.toList
			)
		}
	}

	def isConformant(EObject context, Class<?> expected, JvmTypeReference actual) {
		val actualType = actual.toLightweightTypeReference(context)
		actualType.isSubtypeOf(expected)
	}

	def toLightweightTypeReference(JvmTypeReference typeRef, EObject context) {
		return newTypeReferenceOwner(context).toLightweightTypeReference(typeRef)
	}

	def protected newTypeReferenceOwner(EObject context) {
		return new StandardTypeReferenceOwner(services, context);
	}
}
