/**
 * generated by Xtext 2.10.0
 */
package edelta.ui.outline;

import org.eclipse.emf.ecore.ENamedElement;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EcorePackage;
import org.eclipse.swt.graphics.Image;
import org.eclipse.xtext.ui.editor.outline.IOutlineNode;
import org.eclipse.xtext.ui.editor.outline.impl.DefaultOutlineTreeProvider;
import org.eclipse.xtext.ui.editor.outline.impl.EObjectNode;
import org.eclipse.xtext.util.concurrent.IUnitOfWork;

import com.google.inject.Inject;

import edelta.edelta.EdeltaModifyEcoreOperation;
import edelta.edelta.EdeltaOperation;
import edelta.edelta.EdeltaProgram;
import edelta.resource.derivedstate.EdeltaDerivedStateHelper;

/**
 * Customization of the default outline structure.
 *
 * See https://www.eclipse.org/Xtext/documentation/304_ide_concepts.html#outline
 */
public class EdeltaOutlineTreeProvider extends DefaultOutlineTreeProvider {
	@Inject
	private EdeltaDerivedStateHelper derivedStateHelper;

	/**
	 * This is needed to access the derived state when creating nodes for
	 * Ecore elements, which are stored in a different Resource.
	 */
	private EdeltaProgram currentProgram;

	protected void _createChildren(final IOutlineNode parentNode, final EdeltaProgram p) { // NOSONAR OutlineTreeProvider in Xtext is based on some redefined methods starting with _
		currentProgram = p;
		for (final var o : p.getOperations()) {
			createNode(parentNode, o);
		}
		final var modifyEcoreOperations = p.getModifyEcoreOperations();
		if (modifyEcoreOperations.isEmpty()) {
			return;
		}
		for (final var o : modifyEcoreOperations) {
			createNode(parentNode, o);
		}
		final var eResource = p.eResource();
		final var modifiedElements = derivedStateHelper.getModifiedElements(eResource);
		for (final var ePackage : derivedStateHelper.getCopiedEPackagesMap(eResource).values()) {
			// the cool thing is that we don't need to provide
			// customization in the label provider for EPackage and EClass
			// since Xtext defaults to the .edit plugin :)
			if (modifiedElements.contains(ePackage)) {
				createNode(parentNode, ePackage);
				// only show EPackage with some modifications
			}
		}
	}

	public boolean _isLeaf(final EdeltaOperation m) { // NOSONAR OutlineTreeProvider in Xtext is based on some redefined methods starting with _
		return true;
	}

	public boolean _isLeaf(final EdeltaModifyEcoreOperation m) { // NOSONAR OutlineTreeProvider in Xtext is based on some redefined methods starting with _
		return true;
	}

	@Override
	protected EObjectNode createEObjectNode(IOutlineNode parentNode, EObject modelElement, Image image, Object text,
			boolean isLeaf) {
		// cannot simply check ENamedElement: EGenericType is not an ENamedElement
		if (modelElement.eClass().getEPackage() == EcorePackage.eINSTANCE) {
			var elementForSignificantTestRegion = modelElement;
			/*
			 * custom implementation of readOnly: the default one tries to retrieve the
			 * EObject using the URI and then loading the corresponding resource, but for
			 * copied EPackages we simply return the modelElement for the passed work.
			 * readOnly is used for example by node.getChildren. (see
			 * EdeltaOutlineWithEditorLinker).
			 */
			var eObjectNode = new EObjectNode(modelElement, parentNode, image, text, isLeaf) {
				@Override
				public <T> T readOnly(IUnitOfWork<T, EObject> work) {
					return getDocument().tryReadOnly(state -> work.exec(modelElement));
				}
			};
			if (modelElement instanceof ENamedElement namedElement) {
				// try to associate the node to the responsible XExpression
				var expression = derivedStateHelper.
					getLastResponsibleExpression(currentProgram, namedElement);
				if (expression != null) {
					elementForSignificantTestRegion = expression;
				}
			}
			eObjectNode.setShortTextRegion(
				locationInFileProvider.getSignificantTextRegion(elementForSignificantTestRegion));
			return eObjectNode;
		}
		return super.createEObjectNode(parentNode, modelElement, image, text, isLeaf);
	}
}
