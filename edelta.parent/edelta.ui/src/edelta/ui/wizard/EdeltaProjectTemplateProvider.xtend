/*
 * generated by Xtext 2.20.0
 */
package edelta.ui.wizard

import org.eclipse.core.runtime.Status
import org.eclipse.jdt.core.JavaCore
import org.eclipse.xtext.ui.XtextProjectHelper
import org.eclipse.xtext.ui.util.PluginProjectFactory
import org.eclipse.xtext.ui.wizard.template.IProjectGenerator
import org.eclipse.xtext.ui.wizard.template.IProjectTemplateProvider
import org.eclipse.xtext.ui.wizard.template.ProjectTemplate

import static org.eclipse.core.runtime.IStatus.*

/**
 * Create a list with all project templates to be shown in the template new project wizard.
 * 
 * Each template is able to generate one or more projects. Each project can be configured such that any number of files are included.
 */
class EdeltaProjectTemplateProvider implements IProjectTemplateProvider {
	override getProjectTemplates() {
		#[new HelloWorldProject]
	}
}

@ProjectTemplate(label="Edelta Example Project", icon="project_template.png", description="<p><b>Edelta Example Project</b></p>
<p>An Edelta Example Project, with some initial contents: an Ecore file and an Edelta file.</p>")
final class HelloWorldProject {
	val advanced = check("Advanced:", false)
	val advancedGroup = group("Properties")
	val path = text("Package:", "com/example", "The package path to place the files in", advancedGroup)

	override protected updateVariables() {
		path.enabled = advanced.value
		if (!advanced.value) {
			path.value = "edelta"
		}
	}

	override protected validate() {
		if (path.value.matches('[a-z][a-z0-9_]*(/[a-z][a-z0-9_]*)*'))
			null
		else
			new Status(ERROR, "Wizard", "'" + path + "' is not a valid package name")
	}

	override generateProjects(IProjectGenerator generator) {
		generator.generate(new PluginProjectFactory => [
			projectName = projectInfo.projectName
			location = projectInfo.locationPath
			projectNatures += #[JavaCore.NATURE_ID, "org.eclipse.pde.PluginNature", XtextProjectHelper.NATURE_ID]
			builderIds += #[JavaCore.BUILDER_ID, XtextProjectHelper.BUILDER_ID]
			requiredBundles += "edelta.lib"
			folders += #["src", "model"]
			addFile("modified/README", '''
				Modified ecores will be saved here (see Main.java file)
			'''
			)
			addFile("model/My.ecore", '''
				<?xml version="1.0" encoding="UTF-8"?>
				<ecore:EPackage xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
				    xmlns:ecore="http://www.eclipse.org/emf/2002/Ecore" name="myecore" nsURI="http://www.eclipse.org/emf/2002/Myecore" nsPrefix="myecore">
				  <eClassifiers xsi:type="ecore:EClass" name="MyEClass">
				    <eStructuralFeatures xsi:type="ecore:EAttribute" name="astring" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
				  </eClassifiers>
				  <eClassifiers xsi:type="ecore:EEnum" name="MyENum">
				    <eLiterals name="FirstEnumLiteral"/>
				    <eLiterals name="SecondEnumLiteral" value="1"/>
				  </eClassifiers>
				  <eClassifiers xsi:type="ecore:EClass" name="MyOtherEClass"/>
				</ecore:EPackage>
			''')
			addFile('''src/Example.edelta''', '''
				import org.eclipse.emf.ecore.EClass
				
				// IMPORTANT: ecores must be in a source directory
				// otherwise you can't refer to them
				
				package «path.value.replaceAll("/", ".")»
				
				metamodel "myecore"
				metamodel "ecore"
				
				/*
				 * Reusable function to add standard features to an
				 * {@link EClass}.
				 * 
				 * @param c
				 */
				def addStandardFeatures(EClass c) {
					// use standard EMF API to add manually features
					c.EStructuralFeatures += newEAttribute("name") => [
						// refer to Ecore elements with "ecoreref()"
						EType = ecoreref(EString)
					]
					// and supertypes
					c.ESuperTypes += ecoreref(MyEClass)
				}
				
				// create new EClass with Edelta DSL syntax
				createEClass NewClass in myecore {
					// the created EClass is available through the
					// special implicit parameter 'it' in this block
					
					// reuse your functions
					addStandardFeatures(it)
					
					// create new features with Edelta DSL syntax
					createEAttribute age type EInt {
						// the created EAttribute is available through the
						// special implicit parameter 'it' in this block
						// which can be used as implicit receiver, like 'this'
						lowerBound = 1
					}
					
					// or manually with EMF API
					EStructuralFeatures += newEReference("myReference") => [
						// references to Ecore elements can be fully qualified
						EType = ecoreref(myecore.MyEClass)
						upperBound = -1
						lowerBound = 0
						containment = true
					]
				}
				
				// change existing EClass
				changeEClass myecore.MyEClass {
					EStructuralFeatures += newEReference("myOtherReference") => [
						// new elements are immediately available
						EType = ecoreref(myecore.NewClass)
						containment = false
					]
				}
			''')
			addFile('''src/«path»/Main.java''', '''
				package «path.value.replaceAll("/", ".")»;
				
				import edelta.lib.AbstractEdelta;
				
				public class Main {
				
					public static void main(String[] args) throws Exception {
						// Create an instance of the generated Java class
						AbstractEdelta edelta = new Example();
						// Make sure you load all the used Ecores
						edelta.loadEcoreFile("model/My.ecore");
						// Execute the actual transformations defined in the DSL
						edelta.execute();
						// Save the modified Ecore model into a new path
						edelta.saveModifiedEcores("modified");
					}
				}
			''')
		])
	}
}
