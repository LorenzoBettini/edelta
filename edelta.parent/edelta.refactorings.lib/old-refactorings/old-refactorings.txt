/**
 * @param superclass where to pull up a single instance of the passed attributes
 * @param the attributes that are expected to be the same; the first element will be
 * pulled up in the superclass
 */
def extractIntoSuperclass(EClass superclass, List<EAttribute> attrs){
	val extracted_attr = attrs.head;
	// print(extracted_attr.name);
	// already created from outside in the right package
	// extracted_attr.EContainingClass.EPackage.EClassifiers+=superclass;
	for (attr : attrs) {
		attr.EContainingClass => [
			// set supertype of the EClass of the attribute
			addESuperType(superclass)
			// and then remove the attribute from the original EClass
			EStructuralFeatures -= attr
		]
	}

	superclass.EStructuralFeatures += extracted_attr;
}

/**
 * @param extractedClass the created EClass created representing the extracted metaclass
 * @param reference
 * @param newReferenceName the new name for the reference from the owner class to the
 * extracted class (basically used to rename the original passed reference)
 * @param newOppositeReferenceName the new name for the opposite reference from the original
 * target class to the extracted class (basically used to rename the original opposite reference)
 */
def extractMetaClass(EClass extractedClass, EReference reference,
				String newReferenceName, String newOppositeReferenceName) : void {
	val ref_in = newEReference(newOppositeReferenceName, extractedClass) [
		lowerBound = reference.EOpposite.lowerBound;
		upperBound = 1;
		// f.EOpposite.upperBound;
	];

	val old_ref = newEReference(reference.name, reference.EReferenceType) [
		lowerBound = 1;
		upperBound = 1;
		EOpposite = ref_in;
	];

	extractedClass.addEReference(old_ref);
	ref_in.EOpposite = old_ref;
	reference.EOpposite.lowerBound = 1;
	reference.EOpposite.upperBound = 1;

	extractedClass.addEReference(reference.EOpposite);

	// already created from outside in the right package
	// f.EContainingClass.EPackage.EClassifiers+=extracted_class;
	reference.EReferenceType.addEReference(ref_in);
	reference.EType = extractedClass;
	reference.containment = true;
	reference.name = newReferenceName;
}

/**
 * @param name the name for the extracted class
 * @param reference the reference to extract
 * @param newReferenceName the new name for the reference from the owner class to the
 * extracted class (basically used to rename the original passed reference)
 * @param newOppositeReferenceName the new name for the opposite reference from the original
 * target class to the extracted class (basically used to rename the original opposite reference)
 * @return the extracted metaclass
 */
def extractMetaClass(String name, EReference reference,
			String newReferenceName, String newOppositeReferenceName) {
	if (!checkNotContainment(reference,
			"Cannot apply extractMetaClass on containment reference")) {
		return null
	}
	val owner = reference.EContainingClass
	val ePackage = reference.EContainingClass.EPackage
	val extracted = ePackage.addNewEClass(name)
	val extractedRef = extracted.addNewEReference(reference.name, reference.EReferenceType) [
		makeSingleRequired
	]
	val eOpposite = reference.EOpposite
	if (eOpposite !== null) {
		extracted.addNewEReference(eOpposite.name, owner) [
			makeSingleRequired
			makeBidirectional(reference)
		]
		eOpposite.name = newOppositeReferenceName
		eOpposite.EType = extracted
		eOpposite.makeBidirectional(extractedRef)
	}
	reference.name = newReferenceName
	reference.EType = extracted
	reference.containment = true
	return extracted
}

/**
 * Given a map with key an EClass and value a list of its subclasses,
 * generates an EEnum (in the EClass' package) representing the inheritance relation
 * (the name is the name of the key EClass with "Type" suffix),
 * with an EEnumLiteral for each subclass (the name is the name
 * of the subclass in uppercase); the subclasses are removed, and the
 * key EClass is added an EAttribute with the created EEnum as type
 * (the name is the name of the EEnum, first letter lowercase with "Type"
 * suffix).
 * 
 * For example, give "Base" -> {"Derived1", "Derived2" } as input
 * it creates the EEnum "BaseType" with literals "DERIVED1", "DERIVED2",
 * it adds to "Base" the EAttribute "baseType" of type "BaseType".
 * The EClasses "Derived1" and "Derived2" are removed from the package.
 */
def classificationByHierarchyToEnum(Map<EClass, List<EClass>> classificationsByHierarchy) {
	classificationsByHierarchy
		.forEach[superClass, subClasses|
			val ePackage = superClass.EPackage
			val enumName = ensureEClassifierNameIsUnique
				(ePackage, superClass.name + "Type")
			val enum = ePackage.addNewEEnum(enumName) [
				subClasses.forEach[
					subClass, index |
					val enumLiteralName = ensureEClassifierNameIsUnique
						(ePackage, subClass.name.toUpperCase)
					addNewEEnumLiteral(enumLiteralName) => [
						value = index+1
					]
				]
			]
			superClass.addNewEAttribute(superClass.name.toLowerCase + "Type", enum)
			removeAllElements(subClasses)
		]
}

