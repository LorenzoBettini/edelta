import java.util.Collection
import java.util.List
import java.util.Map
import org.eclipse.emf.ecore.EAttribute
import org.eclipse.emf.ecore.EClass
import org.eclipse.emf.ecore.EClassifier
import org.eclipse.emf.ecore.EDataType
import org.eclipse.emf.ecore.EEnum
import org.eclipse.emf.ecore.EPackage
import org.eclipse.emf.ecore.EReference
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.emf.ecore.util.EcoreUtil
import org.eclipse.xtext.xbase.lib.Pair
import edelta.refactorings.lib.helper.EstructuralFeatureEqualityHelper

package edelta.refactorings.lib

metamodel "ecore"

def addMandatoryAttr(EClass eClass, String attrname, EDataType dataType): EAttribute {
	return eClass.addNewEAttribute(attrname, dataType) [
		makeSingleRequired
	]
}

def mergeReferences(String newReferenceName, EClass newReferenceType, List<EReference> refs): EReference {
	removeAllElements(refs)
	return newEReference(newReferenceName, newReferenceType)
}

def mergeAttributes(String newAttrName, EDataType newAttributeType, List<EAttribute> attrs) : EAttribute {
	removeAllElements(attrs)
	return newEAttribute(newAttrName, newAttributeType)
}

def introduceSubclasses(EClass containingclass, EAttribute attr, EEnum enumType) {
	containingclass.abstract = true;
	for (subc : enumType.ELiterals) {
		containingclass.EPackage.addNewEClass(subc.literal) [
			addESuperType(containingclass)
		];
		containingclass.EStructuralFeatures -= attr;
	}
}

/**
 * @param name the name for the extracted class
 * @param features the features to extract
 * @param newReferenceName the new name for the reference from the owner class to the
 * extracted class
 * @return the extracted metaclass
 */
def extractClass(String name, Collection<EStructuralFeature> features,
			String newReferenceName) {
	val owners = features.map[EContainingClass].toSet
	if (owners.empty)
		return null // TODO: error?
	if (owners.size > 1) {
		owners.forEach[owner|
			showError(owner,
				"Extracted features must belong to the same class: " +
				getEObjectRepr(owner)
			)
		]
		return null
	}
	val owner = owners.head
	val extracted = owner.EPackage.addNewEClass(name)
	owner.addNewEReference(newReferenceName, extracted) [
		makeSingleRequired
		makeContainmentBidirectional
	]
	features.forEach[moveTo(extracted)]
	return extracted
}

/**
 * Makes the EReference, which is assumed to be already part of an EClass,
 * a single required containment reference, adds to the referred
 * type, which is assumed to be set, an opposite required single reference.
 * @param reference
 */
def makeContainmentBidirectional(EReference reference) {
	reference.containment = true
	val owner = reference.EContainingClass
	val referredType = reference.EReferenceType
	referredType.addNewEReference(owner.fromTypeToFeatureName, owner) [
		makeBidirectional(reference)
		makeSingleRequired
	]
}

/**
 * @param name the name for the extracted class
 * @param reference the reference to turn into a reference to the extracted class
 * @return the extracted class
 */
def referenceToClass(String name, EReference reference) {
	if (!checkNotContainment(reference,
			"Cannot apply referenceToClass on containment reference")) {
		return null
	}
	val ePackage = reference.EContainingClass.EPackage
	val extracted = ePackage.addNewEClass(name)
	val extractedRef = extracted.addNewEReference(
		reference.EType.fromTypeToFeatureName, reference.EReferenceType) [
		makeSingleRequired
	]
	val eOpposite = reference.EOpposite
	if (eOpposite !== null) {
		eOpposite.makeBidirectional(extractedRef)
	}
	reference.EType = extracted
	reference.makeContainmentBidirectional
	return extracted
}

def classToReference(EClass cl) {
	// find the EReferences that have type cl
	val references = EcoreUtil.UsageCrossReferencer
		.find(cl, cl.EPackage)
		.filter[EStructuralFeature == ecoreref(eReferenceType)]
		.map[EObject]
		.filter(EReference)
	if (references.isEmpty) {
		showError(cl, "The EClass is not referred: " + getEObjectRepr(cl))
		return
	} else if (references.filter[containment].size > 1) {
		showError(cl, "The EClass is referred by more than one container:\n" +
			references.map["  " + getEObjectRepr(it)].join("\n"))
		return
	}
	val reference = references.head
	val owner = reference.EContainingClass
	// back reference to owner is allowed to be null
	val referenceToOwner = cl.EStructuralFeatures.filter[EType == owner].head
	val otherReferences = cl.EStructuralFeatures
		.filter[it !== referenceToOwner]
		.filter(EReference)
		.toList
	if (otherReferences.empty) {
		showError(cl, "Missing reference to target type: " + getEObjectRepr(cl))
		return
	}
	if (otherReferences.size > 1) {
		showError(cl, "Too many references to target type:\n" +
			otherReferences.map["  " + getEObjectRepr(it)].join("\n"))
		return
	}
	val referenceToTarget = otherReferences.head
	reference.EType = referenceToTarget.EType
	reference.containment = false
	val opposite = referenceToTarget.EOpposite
	if (opposite !== null) {
		makeBidirectional(reference, opposite)
	}
	removeElement(cl)
}

/**
 * Given a non empty list of {@link EStructuralFeature}, which are known to
 * appear in several classes as duplicates, extracts a new common superclass,
 * with the duplicate feature,
 * adds the extracted class as the superclass of the classes with the duplicate
 * feature and removes the duplicate feature from such each class.
 * 
 * The name of the extracted class is the name of the feature, with the first
 * letter capitalized and the "Element" suffix (example, if the feature is
 * "name" the extracted class will be called "NameElement").
 * An additional number can be
 * added as a suffix to avoid name clashes with existing classes.
 * 
 * @param duplicates
 */
def extractSuperclass(List<? extends EStructuralFeature> duplicates) {
	val feature = duplicates.head;
	val containingEPackage = feature.EContainingClass.EPackage
	val superClassName =
		ensureEClassifierNameIsUnique(containingEPackage,
			feature.name.toFirstUpper + "Element")

	extractSuperclass(superClassName, duplicates)
}

/**
 * Given a non empty list of {@link EStructuralFeature}, which are known to
 * appear in several classes as duplicates, extracts a new common superclass,
 * with the given name, with the duplicate feature,
 * adds the extracted class as the superclass of the classes with the duplicate
 * feature and removes the duplicate feature from such each class.
 * 
 * @param name
 * @param duplicates
 */
def extractSuperclass(String name, List<? extends EStructuralFeature> duplicates) {
	val feature = duplicates.head;
	val containingEPackage = feature.EContainingClass.EPackage

	containingEPackage.addNewEClass(name) [
		abstract = true;
		duplicates
			.map[EContainingClass]
			.forEach[c | c.addESuperType(it)]
		pullUpFeatures(duplicates)
	]
}

/**
 * Given a non empty list of {@link EStructuralFeature}, which are known to
 * appear in several subclasses as duplicates, pulls them up in
 * the given common superclass
 * (and removes the duplicate feature from each subclass).
 * 
 * @param dest
 * @param duplicates
 */
def pullUpFeatures(EClass dest, List<? extends EStructuralFeature> duplicates) {
	val feature = duplicates.head
	val equality = new EstructuralFeatureEqualityHelper
	val different = duplicates
		.findFirst[feature !== it && !equality.equals(feature, it)]
	if (different !== null) {
		showError(different,
			"The two features are not equal:\n" +
			"  " + getEObjectRepr(feature) + "\n" +
			"  " + getEObjectRepr(different) + "\n" +
			"  different for " + getEObjectRepr(equality.difference)
		)
		return
	}
	val wrongFeatures = duplicates
		.filter[!EContainingClass.ESuperTypes.contains(dest)]
	if (!wrongFeatures.empty) {
		wrongFeatures.forEach[
			showError(it,
				"Not a direct subclass of destination: " +
					getEObjectRepr(EContainingClass)
			)
		]
		return
	}
	feature.copyTo(dest)
	removeAllElements(duplicates)
}

/**
 * Ensures that the proposed classifier name is unique within the specified
 * package; if not, it appends an incremental index until the name
 * is actually unique
 */
def ensureEClassifierNameIsUnique(EPackage ePackage, String proposedName) {
	var className = proposedName
	val currentEClassifiersNames =
		ePackage.EClassifiers.map[name].sort
	var counter = 1
	// make sure the new class is unique by name in the package
	while (currentEClassifiersNames.contains(className)) {
		className += (counter++)
	}
	return className
}

/**
 * Fix all the passed redundant containers (in the shape of pairs)
 * by setting the eOpposite property.
 * 
 * That is, given the pair r1 -> r2, then r2 is set as the opposite
 * reference of r1 and viceversa.
 */
def redundantContainerToEOpposite(Iterable<Pair<EReference, EReference>> redundantContainers) {
	for (redundant : redundantContainers) {
		makeBidirectional(redundant.key, redundant.value)
	}
}

/**
 * Given a map with key an EClass and value a list of its subclasses,
 * generates an EEnum (in the EClass' package) representing the inheritance relation
 * (the name is the name of the key EClass with "Type" suffix),
 * with an EEnumLiteral for each subclass (the name is the name
 * of the subclass in uppercase); the subclasses are removed, and the
 * key EClass is added an EAttribute with the created EEnum as type
 * (the name is the name of the EEnum, first letter lowercase with "Type"
 * suffix).
 * 
 * For example, give "Base" -> {"Derived1", "Derived2" } as input
 * it creates the EEnum "BaseType" with literals "DERIVED1", "DERIVED2",
 * it adds to "Base" the EAttribute "baseType" of type "BaseType".
 * The EClasses "Derived1" and "Derived2" are removed from the package.
 */
def classificationByHierarchyToEnum(Map<EClass, List<EClass>> classificationsByHierarchy) {
	classificationsByHierarchy
		.forEach[superClass, subClasses|
			val ePackage = superClass.EPackage
			val enumName = ensureEClassifierNameIsUnique
				(ePackage, superClass.name + "Type")
			val enum = ePackage.addNewEEnum(enumName) [
				subClasses.forEach[
					subClass, index |
					val enumLiteralName = ensureEClassifierNameIsUnique
						(ePackage, subClass.name.toUpperCase)
					addNewEEnumLiteral(enumLiteralName) => [
						value = index+1
					]
				]
			]
			superClass.addNewEAttribute(superClass.name.toLowerCase + "Type", enum)
			removeAllElements(subClasses)
		]
}

/**
 * Turns the given EClasses to abstract
 */
def makeAbstract(Iterable<EClass> classes) {
	classes.forEach[abstract = true]
}

/**
 * Turns the given EClasses to NON abstract
 */
def makeConcrete(Iterable<EClass> classes) {
	classes.forEach[abstract = false]
}

def fromTypeToFeatureName(EClassifier type) {
	type.name.toFirstLower
}

/**
 * @param reference the reference that must not be a containment reference
 * @param message the message to show in case the reference
 * is a containment reference
 * @return true if the passed reference is not a containment reference
 */
def checkNotContainment(EReference reference, String message) : boolean {
	val containment = reference.containment
	if (containment)
		showError(reference, message + ": " + getEObjectRepr(reference))
	return !containment
}
