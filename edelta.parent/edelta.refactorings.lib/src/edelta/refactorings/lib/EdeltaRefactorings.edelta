import edelta.refactorings.lib.helper.EdeltaFeatureDifferenceFinder
import java.util.Collection
import java.util.List
import java.util.function.Predicate
import org.eclipse.emf.ecore.EAttribute
import org.eclipse.emf.ecore.EClass
import org.eclipse.emf.ecore.EClassifier
import org.eclipse.emf.ecore.EDataType
import org.eclipse.emf.ecore.EEnum
import org.eclipse.emf.ecore.EPackage
import org.eclipse.emf.ecore.EReference
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.emf.ecore.util.EcoreUtil

package edelta.refactorings.lib

metamodel "ecore"

def addMandatoryAttribute(EClass eClass, String attributeName, EDataType dataType): EAttribute {
	return eClass.addNewEAttribute(attributeName, dataType) [
		makeSingleRequired
	]
}

def addMandatoryReference(EClass eClass, String referenceName, EClass type): EReference {
	return eClass.addNewEReference(referenceName, type) [
		makeSingleRequired
	]
}

/**
 * Merges the given features into a single new feature in the containing class.
 * The features must be compatible (same containing class, same type, same cardinality, etc).
 * 
 * @param newFeatureName
 * @param features
 * @return the new feature added to the containing class of the features
 */
def mergeFeatures(String newFeatureName, Collection<EStructuralFeature> features) : EStructuralFeature {
	val diffFinder = new EdeltaFeatureDifferenceFinder().ignoringName
	if (!checkNoDifferences(features, diffFinder, "The two features cannot be merged"))
		return null
	val feature = features.head
	val owner = feature.EContainingClass
	val copy = feature.copyToAs(owner, newFeatureName)
	removeAllElements(features)
	return copy
}

/**
 * Merges the given features into the single given existing feature in the containing class.
 * The features must be compatible (same containing class, same type, same cardinality, etc)
 * and their types must be subtypes of the specified feature.
 * 
 * @param feature the features will be merged into this feature
 * @param features
 */
def mergeFeatures(EStructuralFeature feature, Collection<EStructuralFeature> features) : EStructuralFeature {
	val diffFinder = new EdeltaFeatureDifferenceFinder()
		.ignoringName
		.ignoringType
	if (!checkCompliant(feature, features) ||
		!checkNoDifferences(#[feature] + features, diffFinder, "The two features cannot be merged"))
		return null
	removeAllElements(features)
	return feature
}

/**
 * Merges the given features into a single new feature, with the given type, in the containing class.
 * The features must be compatible (same containing class, same type, same cardinality, etc)
 * and their types must be subtypes of the specified type.
 * 
 * @param newFeatureName
 * @param type
 * @param features
 */
def mergeFeatures(String newFeatureName, EClassifier type, Collection<EStructuralFeature> features) : EStructuralFeature {
	val feature = features.head
	val owner = feature.EContainingClass
	val copy = feature.copyToAs(owner, newFeatureName, type)
	mergeFeatures(copy, features)
	return copy
}

/**
 * Given an EAttribute, expected to have an EEnum type, creates a subclass of
 * the containing class for each value of the referred EEnum
 * (each subclass is given a name corresponding to the the EEnumLiteral,
 * all lowercase but the first letter, for example, given the literal
 * "LITERAL1", the subclass is given the name "Literal1").
 * The attribute will then be removed and so will the EEnum.
 * The original containing EClass is made abstract.
 * 
 * @param attr
 * @return the collection of created subclasses
 */
def enumToSubclasses(EAttribute attr) : Collection<EClass> {
	val type = attr.EAttributeType
	if (type instanceof EEnum) {
		val createdSubclasses = newArrayList
		val owner = attr.EContainingClass
		val ePackage = owner.EPackage
		owner.makeAbstract
		for (subc : type.ELiterals) {
			val subclassName = ensureEClassifierNameIsUnique
				(ePackage, subc.literal.toLowerCase.toFirstUpper)
			createdSubclasses += ePackage.addNewEClass(subclassName) [
				addESuperType(owner)
			]
		}
		removeElement(type) // will also remove the attribute
		return createdSubclasses
	} else {
		showError(attr,
			"Not an EEnum: " + getEObjectRepr(type)
		)
		return null
	}
}

/**
 * Given a collection of subclasses, which are expected to be direct subclasses of
 * an EClass, say superclass, generates an EEnum (in the superclass' package)
 * with the specified name, representing the inheritance relation,
 * with an EEnumLiteral for each subclass (the name is the name
 * of the subclass in uppercase); the subclasses are removed, and
 * an attributed is added to the superclass with the created EEnum as type
 * (the name is the name of the EEnum, first letter lowercase).
 * 
 * For example, given the name "BaseType" and the collection of classes
 * {"Derived1", "Derived2"} subclasses of the superclass "Base",
 * it creates the EEnum "BaseType" with literals "DERIVED1", "DERIVED2",
 * (the values will be incremental numbers starting from 0,
 * according to the order of the subclasses in the collection)
 * it adds to "Base" the EAttribute "baseType" of type "BaseType".
 * The EClasses "Derived1" and "Derived2" are removed from the package.
 * 
 * @param name the name for the created EEnum
 * @param subclasses
 * @return the created EAttribute
 */
def subclassesToEnum(String name, Collection<EClass> subclasses) : EAttribute {
	if (!checkNoFeatures(subclasses))
		return null
	val superclass = getSingleDirectSuperclass(subclasses)
	if (superclass === null)
		return null
	val ePackage = superclass.EPackage
	val enum = ePackage.addNewEEnum(name) [
		subclasses.forEach[subClass, index |
			val enumLiteralName = ensureEClassifierNameIsUnique
				(ePackage, subClass.name.toUpperCase)
			addNewEEnumLiteral(enumLiteralName) => [
				value = index
			]
		]
	]
	val attribute = superclass.addNewEAttribute(enum.fromTypeToFeatureName, enum)
	superclass.makeConcrete
	removeAllElements(subclasses)
	return attribute
}

/**
 * @param name the name for the extracted class
 * @param features the features to extract
 * @param newReferenceName the new name for the reference from the owner class to the
 * extracted class
 * @return the extracted metaclass
 */
def extractClass(String name, Collection<EStructuralFeature> features,
			String newReferenceName) {
	val owners = features.map[EContainingClass].toSet
	if (owners.empty)
		return null // TODO: error?
	if (owners.size > 1) {
		owners.forEach[owner|
			showError(owner,
				"Extracted features must belong to the same class: " +
				getEObjectRepr(owner)
			)
		]
		return null
	}
	val owner = owners.head
	val extracted = owner.EPackage.addNewEClass(name)
	owner.addMandatoryReference(newReferenceName, extracted) => [
		makeContainmentBidirectional
	]
	features.moveAllTo(extracted)
	return extracted
}

/**
 * Makes the EReference, which is assumed to be already part of an EClass,
 * a single required containment reference, adds to the referred
 * type, which is assumed to be set, an opposite required single reference.
 * @param reference
 */
def makeContainmentBidirectional(EReference reference) {
	reference.containment = true
	val owner = reference.EContainingClass
	val referredType = reference.EReferenceType
	referredType.addMandatoryReference(owner.fromTypeToFeatureName, owner) => [
		makeBidirectional(reference)
	]
}

/**
 * @param name the name for the extracted class
 * @param reference the reference to turn into a reference to the extracted class
 * @return the extracted class
 */
def referenceToClass(String name, EReference reference) {
	if (!checkNotContainment(reference,
			"Cannot apply referenceToClass on containment reference")) {
		return null
	}
	val ePackage = reference.EContainingClass.EPackage
	val extracted = ePackage.addNewEClass(name)
	val extractedRef = extracted.addMandatoryReference(
		reference.EType.fromTypeToFeatureName, reference.EReferenceType)
	val eOpposite = reference.EOpposite
	if (eOpposite !== null) {
		eOpposite.makeBidirectional(extractedRef)
	}
	reference.EType = extracted
	reference.makeContainmentBidirectional
	return extracted
}

def classToReference(EClass cl) {
	// find the EReferences that have type cl
	val references = findReferencesToClass(cl)
	if (references.isEmpty) {
		showError(cl, "The EClass is not referred: " + getEObjectRepr(cl))
		return
	} else if (references.filter[containment].size > 1) {
		showError(cl, "The EClass is referred by more than one container:\n" +
			references.map["  " + getEObjectRepr(it)].join("\n"))
		return
	}
	val reference = references.head
	val owner = reference.EContainingClass
	// back reference to owner is allowed to be null
	val referenceToOwner = cl.EStructuralFeatures.filter[EType == owner].head
	val otherReferences = cl.EStructuralFeatures
		.filter[it !== referenceToOwner]
		.filter(EReference)
		.toList
	if (otherReferences.empty) {
		showError(cl, "Missing reference to target type: " + getEObjectRepr(cl))
		return
	}
	if (otherReferences.size > 1) {
		showError(cl, "Too many references to target type:\n" +
			otherReferences.map["  " + getEObjectRepr(it)].join("\n"))
		return
	}
	val referenceToTarget = otherReferences.head
	reference.EType = referenceToTarget.EType
	reference.containment = false
	val opposite = referenceToTarget.EOpposite
	if (opposite !== null) {
		makeBidirectional(reference, opposite)
	}
	removeElement(cl)
}

/**
 * Given a non empty list of {@link EStructuralFeature}, which are known to
 * appear in several classes as duplicates, extracts a new common superclass,
 * with the duplicate feature,
 * adds the extracted class as the superclass of the classes with the duplicate
 * feature and removes the duplicate feature from such each class.
 * 
 * The name of the extracted class is the name of the feature, with the first
 * letter capitalized and the "Element" suffix (example, if the feature is
 * "name" the extracted class will be called "NameElement").
 * An additional number can be
 * added as a suffix to avoid name clashes with existing classes.
 * 
 * @param duplicates
 */
def extractSuperclass(List<? extends EStructuralFeature> duplicates) {
	val feature = duplicates.head;
	val containingEPackage = feature.EContainingClass.EPackage
	val superClassName =
		ensureEClassifierNameIsUnique(containingEPackage,
			feature.name.toFirstUpper + "Element")

	extractSuperclass(superClassName, duplicates)
}

/**
 * Given a non empty list of {@link EStructuralFeature}, which are known to
 * appear in several classes as duplicates, extracts a new common superclass,
 * with the given name, with the duplicate feature,
 * adds the extracted class as the superclass of the classes with the duplicate
 * feature and removes the duplicate feature from such each class.
 * 
 * @param name
 * @param duplicates
 */
def extractSuperclass(String name, List<? extends EStructuralFeature> duplicates) {
	val feature = duplicates.head;
	val containingEPackage = feature.EContainingClass.EPackage

	containingEPackage.addNewEClass(name) [
		makeAbstract
		duplicates
			.map[EContainingClass]
			.forEach[c | c.addESuperType(it)]
		pullUpFeatures(duplicates)
	]
}

/**
 * Given a non empty list of {@link EStructuralFeature}, which are known to
 * appear in several subclasses as duplicates, pulls them up in
 * the given common superclass
 * (and removes the duplicate feature from each subclass).
 * 
 * @param dest
 * @param duplicates
 */
def pullUpFeatures(EClass dest, List<? extends EStructuralFeature> duplicates) {
	val diffFinder = new EdeltaFeatureDifferenceFinder().ignoringContainingClass
	if (!checkNoDifferences(duplicates, diffFinder, "The two features are not equal"))
		return 

	val wrongFeatures = duplicates
		.filter[!EContainingClass.ESuperTypes.contains(dest)]
	if (!wrongFeatures.empty) {
		wrongFeatures.forEach[
			showError(it,
				"Not a direct subclass of destination: " +
					getEObjectRepr(EContainingClass)
			)
		]
		return
	}
	duplicates.head.copyTo(dest)
	removeAllElements(duplicates)
}

/**
 * Ensures that the proposed classifier name is unique within the specified
 * package; if not, it appends an incremental index until the name
 * is actually unique
 */
def ensureEClassifierNameIsUnique(EPackage ePackage, String proposedName) {
	var className = proposedName
	val currentEClassifiersNames =
		ePackage.EClassifiers.map[name].sort
	var counter = 1
	// make sure the new class is unique by name in the package
	while (currentEClassifiersNames.contains(className)) {
		className += (counter++)
	}
	return className
}

def fromTypeToFeatureName(EClassifier type) {
	type.name.toFirstLower
}

/**
 * @param reference the reference that must not be a containment reference
 * @param message the message to show in case the reference
 * is a containment reference
 * @return true if the passed reference is not a containment reference
 */
def checkNotContainment(EReference reference, String message) : boolean {
	val containment = reference.containment
	if (containment)
		showError(reference, message + ": " + getEObjectRepr(reference))
	return !containment
}

/**
 * Makes sure that there are no differences in the passed features,
 * using the specified differenceFinder, otherwise it shows an error message
 * with the details of the differences.
 * 
 * @param features
 * @param differenceFinder
 * @param errorMessage
 * @return true if there are no differences
 */
def checkNoDifferences(Iterable<? extends EStructuralFeature> features,
	EdeltaFeatureDifferenceFinder differenceFinder,
	String errorMessage
) : boolean {
	val feature = features.head
	val different = features
		.findFirst[feature !== it && !differenceFinder.equals(feature, it)]
	if (different !== null) {
		showError(different,
			errorMessage + ":\n" +
			differenceFinder.differenceDetails
		)
		return false
	}
	return true
}

/**
 * Makes sure that the features have types that are subtypes of the
 * specified feature.
 * 
 * @param feature
 * @param features
 * @return true if they are all compliant
 */
def checkCompliant(EStructuralFeature feature, Collection<? extends EStructuralFeature> features) : boolean {
	val Predicate<EStructuralFeature> compliance = if (feature instanceof EReference) {
		[other |
			if (other instanceof EReference)
				feature.EReferenceType.isSuperTypeOf(other.EReferenceType)
			else
				false // attribute's type is surely not compliant
		]
	} else {
		[other | feature.EType === other.EType]
	}
	val nonCompliant = features
		.filter[!compliance.test(it)]
	if (!nonCompliant.empty) {
		showError(feature,
			"features not compliant with type " + getEObjectRepr(feature.EType) + ":\n" +
			nonCompliant
				.map["  " + getEObjectRepr(it) + ": " + getEObjectRepr(EType)].join("\n")
		)
		return false
	}
	return true
}

/**
 * Makes sure the passed EClasses have no feature
 * 
 * @param classes
 * @return true if all the EClasses have no features
 */
def checkNoFeatures(Collection<EClass> classes) : boolean {
	return classes.map[checkNoFeatures].toList.forall[it]
}

/**
 * Makes sure the passed EClass has no feature
 * 
 * @param c
 * @return true if the EClass has no feature
 */
def checkNoFeatures(EClass c) : boolean {
	val features = c.EStructuralFeatures
	val empty = features.empty
	if (!empty) {
		showError(c,
			"Not an empty class: " + getEObjectRepr(c) + ":\n" +
				features.map["  " + EObjectRepr].join("\n")
		)
	}
	return empty
}

/**
 * Finds all the EReferences to the given EClass in the
 * EClass' package
 */
def findReferencesToClass(EClass cl) {
	EcoreUtil.UsageCrossReferencer
		.find(cl, cl.EPackage)
		.filter[EStructuralFeature == ecoreref(eReferenceType)]
		.map[EObject]
		.filter(EReference)
}

/**
 * Checks that the passed subclasses have all exactly one superclass
 * and that it is the same and returns that as a result. It also checks
 * that such a common superclass has no further subclasses.
 * 
 * In case of failure, besides reporting errors, it returns null.
 */
def getSingleDirectSuperclass(Collection<EClass> subclasses) {
	val invalid = subclasses.filter[
		ESuperTypes.size != 1
	]
	if (!invalid.empty) {
		invalid.forEach[
			val superclasses = ESuperTypes
			showError(it,
				"Expected one superclass: " + EObjectRepr + " instead of:\n" +
				if (superclasses.empty)
					"  empty"
				else
					superclasses.map["  " + EObjectRepr].join("\n")
			)
		]
		return null
	}
	// now all subclasses are known to have exactly one superclass
	val result = subclasses.head.ESuperTypes.head
	val differences = subclasses
		.filter[ESuperTypes.head !== result]
	if (!differences.empty) {
		differences.forEach[
			showError(it,
				"Wrong superclass of " + EObjectRepr + ":\n"+
				"  Expected: " + getEObjectRepr(result) + "\n" +
				"  Actual  : " + getEObjectRepr(ESuperTypes.head)
			)
		]
		return null
	}
	val additionalSubclasses = directSubclasses(result).toSet
	additionalSubclasses.removeAll(subclasses.toSet)
	if (!additionalSubclasses.empty) {
		showError(result,
			"The class has additional subclasses:\n" +
			additionalSubclasses.map["  " + EObjectRepr].join("\n")
		)
		return null
	}
	return result
}

def directSubclasses(EClass cl) {
	EcoreUtil.UsageCrossReferencer
		.find(cl, cl.EPackage)
		.filter[EStructuralFeature == ecoreref(eSuperTypes)]
		.map[EObject as EClass]
}

